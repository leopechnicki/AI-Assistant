<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hex Overlay</title>
<style>
  :root {
    --bg: rgba(15, 15, 20, 0.88);
    --bg-solid: #0f0f14;
    --text: #e8e3d5;
    --dim: #7b7f87;
    --accent: #f6c453;
    --success: #7dd3a5;
    --error: #f97066;
    --border: rgba(255,255,255,0.08);
    --input-bg: rgba(255,255,255,0.06);
    --radius: 12px;
    --font: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font);
    font-size: 13px;
    line-height: 1.6;
    color: var(--text);
    background: transparent;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
  }

  #overlay-container {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 420px;
    max-height: calc(100vh - 40px);
    background: var(--bg);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.03);
    transition: opacity 0.2s ease;
  }

  #overlay-container.minimized {
    max-height: 44px;
    overflow: hidden;
  }

  #overlay-container.hidden {
    opacity: 0;
    pointer-events: none;
  }

  /* Header / drag bar */
  #header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    border-bottom: 1px solid var(--border);
    cursor: grab;
    flex-shrink: 0;
  }

  #header:active { cursor: grabbing; }

  #header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--dim);
    transition: background 0.3s ease;
  }

  #status-dot.connected { background: var(--success); }
  #status-dot.error { background: var(--error); }

  #title {
    font-size: 12px;
    font-weight: 600;
    color: var(--accent);
    letter-spacing: 0.5px;
  }

  #header-actions {
    display: flex;
    gap: 6px;
  }

  .header-btn {
    background: none;
    border: none;
    color: var(--dim);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 4px;
    border-radius: 4px;
    transition: color 0.15s, background 0.15s;
    line-height: 1;
  }

  .header-btn:hover {
    color: var(--text);
    background: rgba(255,255,255,0.08);
  }

  /* Messages area */
  #messages {
    flex: 1;
    overflow-y: auto;
    padding: 10px 14px;
    max-height: 50vh;
    scroll-behavior: smooth;
  }

  #messages::-webkit-scrollbar { width: 4px; }
  #messages::-webkit-scrollbar-track { background: transparent; }
  #messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .message {
    margin-bottom: 10px;
    animation: fadeIn 0.2s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .message-role {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    margin-bottom: 3px;
  }

  .message-role.user { color: var(--accent); }
  .message-role.assistant { color: var(--success); }

  .message-text {
    color: var(--text);
    word-wrap: break-word;
    white-space: pre-wrap;
  }

  .message-text code {
    background: rgba(255,255,255,0.06);
    padding: 1px 5px;
    border-radius: 3px;
    font-size: 12px;
  }

  .streaming-cursor {
    display: inline-block;
    width: 6px;
    height: 14px;
    background: var(--accent);
    margin-left: 2px;
    animation: blink 0.8s step-end infinite;
    vertical-align: text-bottom;
  }

  @keyframes blink {
    50% { opacity: 0; }
  }

  /* Input area */
  #input-area {
    display: flex;
    align-items: center;
    padding: 8px 10px;
    border-top: 1px solid var(--border);
    gap: 8px;
    flex-shrink: 0;
  }

  #message-input {
    flex: 1;
    background: var(--input-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    color: var(--text);
    font-family: var(--font);
    font-size: 13px;
    outline: none;
    resize: none;
    min-height: 36px;
    max-height: 80px;
    transition: border-color 0.15s;
  }

  #message-input:focus {
    border-color: var(--accent);
  }

  #message-input::placeholder {
    color: var(--dim);
  }

  #send-btn {
    background: var(--accent);
    border: none;
    color: #0f0f14;
    font-family: var(--font);
    font-size: 12px;
    font-weight: 700;
    padding: 8px 14px;
    border-radius: 8px;
    cursor: pointer;
    transition: opacity 0.15s;
    flex-shrink: 0;
  }

  #send-btn:hover { opacity: 0.85; }
  #send-btn:disabled { opacity: 0.4; cursor: not-allowed; }

  /* Connection status bar */
  #status-bar {
    padding: 6px 14px;
    font-size: 10px;
    color: var(--dim);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }

  #model-label {
    color: var(--accent);
    font-weight: 600;
  }

  /* Empty state */
  #empty-state {
    padding: 30px 20px;
    text-align: center;
    color: var(--dim);
    font-size: 12px;
  }

  #empty-state .logo {
    font-size: 24px;
    margin-bottom: 8px;
    color: var(--accent);
  }
</style>
</head>
<body>

<div id="overlay-container">
  <div id="header">
    <div id="header-left">
      <div id="status-dot"></div>
      <span id="title">HEX OVERLAY</span>
    </div>
    <div id="header-actions">
      <button class="header-btn" id="btn-minimize" title="Minimize (Ctrl+Shift+M)">&#x2500;</button>
      <button class="header-btn" id="btn-hide" title="Hide (Ctrl+Shift+H)">&#x2715;</button>
    </div>
  </div>

  <div id="messages">
    <div id="empty-state">
      <div class="logo">&#x2B21;</div>
      <div>Hex AI Overlay</div>
      <div style="margin-top:4px;">Type a message to start</div>
    </div>
  </div>

  <div id="input-area">
    <textarea id="message-input" rows="1" placeholder="Ask anything..." autofocus></textarea>
    <button id="send-btn" disabled>Send</button>
  </div>

  <div id="status-bar">
    <span id="connection-status">Connecting...</span>
    <span id="model-label"></span>
  </div>
</div>

<script>
(function() {
  // Config injected by server or parsed from URL
  const params = new URLSearchParams(location.search);
  const wsUrl = params.get('ws') || `ws://${location.hostname}:${location.port}`;
  const token = params.get('token') || '';
  const sessionKey = params.get('session') || 'overlay';

  // DOM
  const container = document.getElementById('overlay-container');
  const statusDot = document.getElementById('status-dot');
  const messages = document.getElementById('messages');
  const emptyState = document.getElementById('empty-state');
  const input = document.getElementById('message-input');
  const sendBtn = document.getElementById('send-btn');
  const connStatus = document.getElementById('connection-status');
  const modelLabel = document.getElementById('model-label');
  const btnMinimize = document.getElementById('btn-minimize');
  const btnHide = document.getElementById('btn-hide');

  let ws = null;
  let connected = false;
  let chatRunId = null;
  let streamText = '';
  let streamEl = null;
  let pendingRequests = {};
  let msgIdCounter = 0;
  let reconnectDelay = 800;

  // Dragging
  let dragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  const header = document.getElementById('header');
  header.addEventListener('mousedown', (e) => {
    if (e.target.closest('.header-btn')) return;
    dragging = true;
    const rect = container.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    header.style.cursor = 'grabbing';
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    container.style.right = 'auto';
    container.style.left = (e.clientX - dragOffsetX) + 'px';
    container.style.top = (e.clientY - dragOffsetY) + 'px';
  });
  document.addEventListener('mouseup', () => {
    dragging = false;
    header.style.cursor = 'grab';
  });

  // Minimize / hide
  btnMinimize.addEventListener('click', () => {
    container.classList.toggle('minimized');
  });
  btnHide.addEventListener('click', () => {
    container.classList.add('hidden');
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'H') {
      container.classList.toggle('hidden');
      e.preventDefault();
    }
    if (e.ctrlKey && e.shiftKey && e.key === 'M') {
      container.classList.toggle('minimized');
      e.preventDefault();
    }
  });

  // Input handling
  input.addEventListener('input', () => {
    sendBtn.disabled = !input.value.trim() || !connected;
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 80) + 'px';
  });
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
  sendBtn.addEventListener('click', sendMessage);

  function generateId() {
    return 'msg-' + (++msgIdCounter) + '-' + Math.random().toString(36).slice(2, 8);
  }

  function sendMessage() {
    const text = input.value.trim();
    if (!text || !connected) return;

    emptyState.style.display = 'none';
    addMessage('user', text);
    input.value = '';
    input.style.height = 'auto';
    sendBtn.disabled = true;

    const runId = generateId();
    chatRunId = runId;
    streamText = '';
    streamEl = addMessage('assistant', '', true);

    wsRequest('chat.send', {
      sessionKey: sessionKey,
      message: text,
      deliver: false,
      idempotencyKey: runId,
    }).catch((err) => {
      chatRunId = null;
      if (streamEl) {
        streamEl.querySelector('.message-text').textContent = 'Error: ' + String(err);
      }
    });
  }

  function addMessage(role, text, streaming) {
    const div = document.createElement('div');
    div.className = 'message';

    const roleDiv = document.createElement('div');
    roleDiv.className = 'message-role ' + role;
    roleDiv.textContent = role === 'user' ? 'You' : 'Hex';
    div.appendChild(roleDiv);

    const textDiv = document.createElement('div');
    textDiv.className = 'message-text';
    textDiv.textContent = text || '';
    if (streaming) {
      const cursor = document.createElement('span');
      cursor.className = 'streaming-cursor';
      textDiv.appendChild(cursor);
    }
    div.appendChild(textDiv);

    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
    return div;
  }

  function extractMessageText(message) {
    if (!message) return '';
    if (typeof message === 'string') return message;
    if (Array.isArray(message)) {
      return message
        .filter(b => b && b.type === 'text')
        .map(b => b.text || '')
        .join('');
    }
    if (message.content) return extractMessageText(message.content);
    if (message.text) return message.text;
    return '';
  }

  // WebSocket
  function connect() {
    try {
      ws = new WebSocket(wsUrl);
    } catch (e) {
      scheduleReconnect();
      return;
    }

    ws.addEventListener('open', () => {
      // Send connect handshake
      const connectParams = {
        minProtocol: 3,
        maxProtocol: 3,
        client: {
          id: 'hex-overlay',
          version: 'dev',
          platform: navigator.platform || 'web',
          mode: 'webchat',
        },
        role: 'operator',
        scopes: ['operator.admin'],
        caps: [],
        auth: token ? { token: token } : undefined,
        userAgent: navigator.userAgent,
        locale: navigator.language,
      };
      wsRequest('connect', connectParams).then((hello) => {
        connected = true;
        reconnectDelay = 800;
        statusDot.className = 'connected';
        connStatus.textContent = 'Connected';
        sendBtn.disabled = !input.value.trim();

        // Load chat history
        wsRequest('chat.history', { sessionKey: sessionKey, limit: 50 }).then((res) => {
          if (res && res.messages && res.messages.length > 0) {
            emptyState.style.display = 'none';
            for (const msg of res.messages) {
              const role = msg.role || 'assistant';
              const text = extractMessageText(msg);
              if (text) addMessage(role, text);
            }
          }
        }).catch(() => {});
      }).catch(() => {
        ws.close();
      });
    });

    ws.addEventListener('message', (ev) => {
      let parsed;
      try { parsed = JSON.parse(String(ev.data)); } catch { return; }

      if (parsed.type === 'res') {
        const p = pendingRequests[parsed.id];
        if (p) {
          delete pendingRequests[parsed.id];
          if (parsed.ok) p.resolve(parsed.payload);
          else p.reject(new Error(parsed.error?.message || 'request failed'));
        }
        return;
      }

      if (parsed.type === 'event') {
        handleEvent(parsed);
      }
    });

    ws.addEventListener('close', () => {
      connected = false;
      ws = null;
      statusDot.className = '';
      connStatus.textContent = 'Disconnected';
      sendBtn.disabled = true;
      // Flush pending
      for (const id of Object.keys(pendingRequests)) {
        pendingRequests[id].reject(new Error('disconnected'));
        delete pendingRequests[id];
      }
      scheduleReconnect();
    });

    ws.addEventListener('error', () => {});
  }

  function scheduleReconnect() {
    setTimeout(connect, reconnectDelay);
    reconnectDelay = Math.min(reconnectDelay * 1.7, 15000);
  }

  function wsRequest(method, params) {
    return new Promise((resolve, reject) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        reject(new Error('not connected'));
        return;
      }
      const id = generateId();
      pendingRequests[id] = { resolve, reject };
      ws.send(JSON.stringify({ type: 'req', id, method, params }));
    });
  }

  function handleEvent(evt) {
    if (evt.event === 'chat') {
      const payload = evt.payload;
      if (!payload || payload.sessionKey !== sessionKey) return;

      if (payload.state === 'delta') {
        const text = extractMessageText(payload.message);
        if (typeof text === 'string' && text.length >= streamText.length) {
          streamText = text;
          if (streamEl) {
            const textDiv = streamEl.querySelector('.message-text');
            textDiv.textContent = streamText;
            const cursor = document.createElement('span');
            cursor.className = 'streaming-cursor';
            textDiv.appendChild(cursor);
            messages.scrollTop = messages.scrollHeight;
          }
        }
      } else if (payload.state === 'final') {
        const text = extractMessageText(payload.message);
        if (streamEl) {
          const textDiv = streamEl.querySelector('.message-text');
          textDiv.textContent = text || streamText;
        }
        chatRunId = null;
        streamText = '';
        streamEl = null;
        sendBtn.disabled = !input.value.trim() || !connected;
      } else if (payload.state === 'aborted' || payload.state === 'error') {
        if (streamEl) {
          const textDiv = streamEl.querySelector('.message-text');
          if (payload.state === 'error') {
            textDiv.textContent = 'Error: ' + (payload.errorMessage || 'unknown error');
          } else {
            textDiv.textContent = streamText || '(aborted)';
          }
        }
        chatRunId = null;
        streamText = '';
        streamEl = null;
        sendBtn.disabled = !input.value.trim() || !connected;
      }
    }
  }

  // Start
  connect();

  // Model label
  modelLabel.textContent = 'Codex';
})();
</script>
</body>
</html>
